[
  {
    "projectId": "14d42bad-3783-4357-b5a2-b83f83c5dd91",
    "testId": "ead86755-6582-474f-a512-8bb399ea9c25",
    "userId": "14b89418-40d1-70e8-88e4-c2f9631e0e84",
    "title": "TC001-patient_appointment_booking_validation",
    "description": "Test the appointment booking API to ensure it enforces validation rules such as no booking for past dates, one appointment per specialization per day per patient, and daily limit of 15 appointments per doctor.",
    "code": "import requests\nfrom datetime import datetime, timedelta\nimport pytest\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\n\n# Assuming we have API endpoints:\n# POST /api/patients/          -> create patient\n# DELETE /api/patients/{id}/   -> delete patient\n# POST /api/doctors/           -> create doctor\n# DELETE /api/doctors/{id}/    -> delete doctor\n# POST /api/appointments/      -> book appointment\n# DELETE /api/appointments/{id}/ -> delete appointment\n\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    # Add authentication headers if needed, e.g.\n    # \"Authorization\": \"Bearer <token>\",\n}\n\n\ndef create_patient():\n    payload = {\n        \"first_name\": \"Test\",\n        \"last_name\": \"Patient\",\n        \"email\": f\"test_patient_{datetime.utcnow().timestamp()}@example.com\",\n        \"password\": \"TestPass123!\",\n        \"emergency_contact\": \"0911234567\"\n    }\n    resp = requests.post(f\"{BASE_URL}/api/patients/\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef delete_patient(patient_id):\n    requests.delete(f\"{BASE_URL}/api/patients/{patient_id}/\", headers=HEADERS, timeout=TIMEOUT)\n\n\ndef create_doctor(specialization):\n    payload = {\n        \"first_name\": \"Test\",\n        \"last_name\": \"Doctor\",\n        \"email\": f\"test_doctor_{specialization}_{datetime.utcnow().timestamp()}@example.com\",\n        \"password\": \"TestPass123!\",\n        \"specialization\": specialization,\n        # adding minimal required fields for doctor creation\n        \"availability\": [\n          {\"day\": \"Monday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"},\n          {\"day\": \"Tuesday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"},\n          {\"day\": \"Wednesday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"},\n          {\"day\": \"Thursday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"},\n          {\"day\": \"Friday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"}\n        ]\n    }\n    resp = requests.post(f\"{BASE_URL}/api/doctors/\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\n\ndef delete_doctor(doctor_id):\n    requests.delete(f\"{BASE_URL}/api/doctors/{doctor_id}/\", headers=HEADERS, timeout=TIMEOUT)\n\n\ndef book_appointment(patient_id, doctor_id, appointment_date, start_time, specialization):\n    payload = {\n        \"patient_id\": patient_id,\n        \"doctor_id\": doctor_id,\n        \"appointment_date\": appointment_date,\n        \"start_time\": start_time,\n        \"specialization\": specialization,\n        \"appointment_type\": \"SCHEDULED\"\n    }\n    resp = requests.post(f\"{BASE_URL}/api/appointments/\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n    return resp\n\n\ndef delete_appointment(appointment_id):\n    requests.delete(f\"{BASE_URL}/api/appointments/{appointment_id}/\", headers=HEADERS, timeout=TIMEOUT)\n\n\ndef test_patient_appointment_booking_validation():\n    # Create test patient\n    patient = create_patient()\n    patient_id = patient[\"id\"]\n\n    # Create test doctor with specialization \"Cardiology\"\n    doctor = create_doctor(\"Cardiology\")\n    doctor_id = doctor[\"id\"]\n\n    appointments_created = []\n    try:\n        today = datetime.utcnow().date()\n        past_date = (today - timedelta(days=1)).isoformat()\n        future_date = (today + timedelta(days=1)).isoformat()\n        start_time = \"10:00\"\n\n        # 1) Test booking an appointment for a past date (should fail)\n        resp = book_appointment(patient_id, doctor_id, past_date, start_time, \"Cardiology\")\n        assert resp.status_code == 400, \"Booking appointment for past date should fail\"\n        assert \"past date\" in resp.text.lower() or \"invalid\" in resp.text.lower()\n\n        # 2) Book first appointment for patient in Cardiology specialization on future_date (should succeed)\n        resp = book_appointment(patient_id, doctor_id, future_date, start_time, \"Cardiology\")\n        assert resp.status_code == 201, f\"Expected 201 Created, got {resp.status_code}\"\n        appointment1 = resp.json()\n        appointments_created.append(appointment1[\"id\"])\n\n        # 3) Attempt to book another appointment for the same patient, same specialization, same day (should fail)\n        # Different doctor with same specialization (Create second doctor)\n        doctor2 = create_doctor(\"Cardiology\")\n        doctor2_id = doctor2[\"id\"]\n        try:\n            resp = book_appointment(patient_id, doctor2_id, future_date, \"11:00\", \"Cardiology\")\n            assert resp.status_code == 400, \"Should not allow multiple appointments for same specialization per day per patient\"\n            assert \"one appointment per specialization\" in resp.text.lower() or \"already has an appointment\" in resp.text.lower()\n        finally:\n            delete_doctor(doctor2_id)\n\n        # 4) Book max 15 appointments for the doctor on the same date (different patients)\n        for i in range(2, 17):  # already 1 appointment booked above, book next 15 to exceed limit\n            new_patient = create_patient()\n            p_id = new_patient[\"id\"]\n            try:\n                time = (10 + (i - 2)) % 17  # ensure different hour slots if needed\n                appointment_time = f\"{time:02d}:00\"\n                resp = book_appointment(p_id, doctor_id, future_date, appointment_time, \"Cardiology\")\n                if i <= 15:\n                    # up to 15 appointments should succeed\n                    assert resp.status_code == 201, f\"Appointment {i} should be successful\"\n                    app_id = resp.json()[\"id\"]\n                    appointments_created.append(app_id)\n                else:\n                    # 16th appointment and above should fail\n                    assert resp.status_code == 400, \"Should enforce max 15 appointments per doctor per day\"\n                    assert \"limit\" in resp.text.lower() or \"maximum\" in resp.text.lower()\n                    break\n            finally:\n                delete_patient(p_id)\n\n    finally:\n        # Cleanup appointments\n        for app_id in appointments_created:\n            try:\n                delete_appointment(app_id)\n            except Exception:\n                pass\n        # Cleanup patient and doctor\n        delete_patient(patient_id)\n        delete_doctor(doctor_id)\n\n\ntest_patient_appointment_booking_validation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 3, in <module>\nModuleNotFoundError: No module named 'pytest'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-12T15:07:02.100Z",
    "modified": "2026-01-12T15:07:53.833Z"
  },
  {
    "projectId": "14d42bad-3783-4357-b5a2-b83f83c5dd91",
    "testId": "812a5e50-ab08-4824-8790-18ae7868889d",
    "userId": "14b89418-40d1-70e8-88e4-c2f9631e0e84",
    "title": "TC002-doctor_availability_scheduling_limit",
    "description": "Verify the API for doctor availability scheduling enforces the maximum of 15 appointments per day and respects the weekly availability time slots.",
    "code": "import requests\nfrom datetime import datetime, timedelta\nimport random\nimport string\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\n\n# Helpers to create unique values\ndef random_string(length=6):\n    letters = string.ascii_lowercase\n    return ''.join(random.choice(letters) for _ in range(length))\n\ndef create_doctor():\n    url = f\"{BASE_URL}/api/doctors/\"\n    payload = {\n        \"name\": \"Doctor \" + random_string(),\n        \"specialization\": \"General\",\n        \"email\": f\"{random_string()}@hospital.com\"\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef delete_doctor(doctor_id):\n    url = f\"{BASE_URL}/api/doctors/{doctor_id}/\"\n    resp = requests.delete(url, timeout=TIMEOUT)\n    return resp\n\ndef create_patient():\n    url = f\"{BASE_URL}/api/patients/\"\n    payload = {\n        \"name\": \"Patient \" + random_string(),\n        \"email\": f\"{random_string()}@test.com\",\n        \"emergency_contact\": \"0911234567\",\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef delete_patient(patient_id):\n    url = f\"{BASE_URL}/api/patients/{patient_id}/\"\n    resp = requests.delete(url, timeout=TIMEOUT)\n    return resp\n\ndef create_doctor_availability(doctor_id, weekday, start_time, end_time):\n    url = f\"{BASE_URL}/api/doctors/{doctor_id}/availability/\"\n    payload = {\n        \"weekday\": weekday,  # 0=Monday ... 6=Sunday\n        \"start_time\": start_time,  # \"09:00\"\n        \"end_time\": end_time       # \"17:00\"\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef delete_doctor_availability(doctor_id, availability_id):\n    url = f\"{BASE_URL}/api/doctors/{doctor_id}/availability/{availability_id}/\"\n    resp = requests.delete(url, timeout=TIMEOUT)\n    return resp\n\ndef create_appointment(doctor_id, patient_id, appointment_date, start_time):\n    url = f\"{BASE_URL}/api/appointments/\"\n    payload = {\n        \"doctor\": doctor_id,\n        \"patient\": patient_id,\n        \"appointment_date\": appointment_date.strftime(\"%Y-%m-%d\"),\n        \"start_time\": start_time,\n        \"status\": \"SCHEDULED\"\n    }\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    return resp\n\ndef delete_appointment(appointment_id):\n    url = f\"{BASE_URL}/api/appointments/{appointment_id}/\"\n    resp = requests.delete(url, timeout=TIMEOUT)\n    return resp\n\ndef test_doctor_availability_scheduling_limit():\n    # Create doctor\n    doctor = create_doctor()\n    doctor_id = doctor[\"id\"]\n\n    # Create patient pool\n    patients = []\n    try:\n        for _ in range(16):\n            patient = create_patient()\n            patients.append(patient)\n        \n        # Setup weekly availability for doctor: Monday 09:00-17:00\n        availability = create_doctor_availability(doctor_id, weekday=0, start_time=\"09:00\", end_time=\"17:00\")\n        availability_id = availability[\"id\"]\n\n        # Target appointment date: Next Monday\n        today = datetime.now()\n        days_ahead = 0 - today.weekday()\n        if days_ahead <= 0:\n            days_ahead += 7\n        appointment_date = (today + timedelta(days=days_ahead)).date()\n\n        # Each appointment will start at 09:00, incremental 30 minutes slots (09:00, 09:30, 10:00, ...)\n        appointment_duration_minutes = 30\n        slots_count = 15  # max per day\n        start_hour = 9\n        start_minute = 0\n\n        created_appointments_ids = []\n\n        # Book 15 appointments successfully\n        for i in range(slots_count):\n            hour = start_hour + (start_minute + i * appointment_duration_minutes) // 60\n            minute = (start_minute + i * appointment_duration_minutes) % 60\n            start_time = f\"{hour:02d}:{minute:02d}\"\n\n            resp = create_appointment(doctor_id, patients[i][\"id\"], appointment_date, start_time)\n            assert resp.status_code == 201, f\"Expected 201 Created but got {resp.status_code}\"\n            response_data = resp.json()\n            assert response_data[\"doctor\"] == doctor_id\n            assert response_data[\"patient\"] == patients[i][\"id\"]\n            assert response_data[\"appointment_date\"] == appointment_date.strftime(\"%Y-%m-%d\")\n            assert response_data[\"start_time\"] == start_time\n            assert response_data[\"status\"] == \"SCHEDULED\"\n            created_appointments_ids.append(response_data[\"id\"])\n\n        # Attempt to book the 16th appointment on the same day for the same doctor should fail\n        hour = start_hour + (start_minute + slots_count * appointment_duration_minutes) // 60\n        minute = (start_minute + slots_count * appointment_duration_minutes) % 60\n        start_time = f\"{hour:02d}:{minute:02d}\"\n\n        resp = create_appointment(doctor_id, patients[slots_count][\"id\"], appointment_date, start_time)\n        assert resp.status_code == 400 or resp.status_code == 409, (\n            f\"Expected 400 Bad Request or 409 Conflict for exceeding max appointments, got {resp.status_code}\"\n        )\n        error_data = resp.json()\n        assert \"limit\" in str(error_data).lower() or \"maximum\" in str(error_data).lower()\n\n        # Attempt to book outside the weekly availability (e.g. Sunday)\n        sunday = appointment_date + timedelta(days=6)\n        resp = create_appointment(doctor_id, patients[slots_count][\"id\"], sunday, \"09:00\")\n        assert resp.status_code == 400, f\"Expected 400 Bad Request booking outside availability, got {resp.status_code}\"\n        err = resp.json()\n        assert \"availability\" in str(err).lower() or \"schedule\" in str(err).lower()\n\n    finally:\n        # Cleanup: delete all created appointments\n        for appt_id in created_appointments_ids:\n            delete_appointment(appt_id)\n\n        # Cleanup patients\n        for p in patients:\n            try:\n                delete_patient(p[\"id\"])\n            except Exception:\n                pass\n\n        # Cleanup doctor availability\n        try:\n            delete_doctor_availability(doctor_id, availability_id)\n        except Exception:\n            pass\n\n        # Cleanup doctor\n        delete_doctor(doctor_id)\n\ntest_doctor_availability_scheduling_limit()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 166, in <module>\n  File \"<string>\", line 81, in test_doctor_availability_scheduling_limit\n  File \"<string>\", line 22, in create_doctor\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:9000/api/doctors/\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-12T15:07:02.116Z",
    "modified": "2026-01-12T15:08:24.809Z"
  },
  {
    "projectId": "14d42bad-3783-4357-b5a2-b83f83c5dd91",
    "testId": "5777bfa8-3417-4058-860d-e3f7e23b040a",
    "userId": "14b89418-40d1-70e8-88e4-c2f9631e0e84",
    "title": "TC003-digital_checkin_qrcode_generation",
    "description": "Test the digital check-in API to confirm unique QR codes are generated per appointment and linked correctly to appointment data for patient check-in.",
    "code": "import requests\nimport uuid\nimport datetime\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\n\n# Helper functions to create and delete resources for test\ndef create_doctor():\n    url = f\"{BASE_URL}/doctors/\"\n    doctor_data = {\n        \"name\": f\"Dr. Test {uuid.uuid4()}\",\n        \"specialization\": \"General\"\n    }\n    resp = requests.post(url, json=doctor_data, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef delete_doctor(doctor_id):\n    url = f\"{BASE_URL}/doctors/{doctor_id}/\"\n    resp = requests.delete(url, timeout=TIMEOUT)\n    # ignore errors on delete\n\ndef create_patient():\n    url = f\"{BASE_URL}/patients/\"\n    patient_data = {\n        \"name\": f\"Patient Test {uuid.uuid4()}\",\n        \"email\": f\"patient_{uuid.uuid4().hex[:8]}@example.com\",\n        \"emergency_contact\": \"0911234567\"\n    }\n    resp = requests.post(url, json=patient_data, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef delete_patient(patient_id):\n    url = f\"{BASE_URL}/patients/{patient_id}/\"\n    resp = requests.delete(url, timeout=TIMEOUT)\n    # ignore errors on delete\n\ndef create_appointment(patient_id, doctor_id, appointment_date):\n    url = f\"{BASE_URL}/appointments/\"\n    start_time = \"10:00\"\n    appointment_payload = {\n        \"patient_id\": patient_id,\n        \"doctor_id\": doctor_id,\n        \"appointment_date\": appointment_date,\n        \"start_time\": start_time,\n        \"type\": \"SCHEDULED\"  # Assuming type field exists and SCHEDULED appointments are allowed\n    }\n    resp = requests.post(url, json=appointment_payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef delete_appointment(appointment_id):\n    url = f\"{BASE_URL}/appointments/{appointment_id}/\"\n    resp = requests.delete(url, timeout=TIMEOUT)\n    # ignore errors on delete\n\ndef test_digital_checkin_qrcode_generation():\n    doctor = create_doctor()\n    patient = create_patient()\n    appointment_date = (datetime.date.today() + datetime.timedelta(days=1)).isoformat()\n    appointment1 = None\n    appointment2 = None\n    try:\n        # Create first appointment\n        appointment1 = create_appointment(patient[\"id\"], doctor[\"id\"], appointment_date)\n        # Create second appointment with same patient, doctor but different start_time to simulate different appointment\n        # We must avoid unique constraint on (doctor, appointment_date, start_time), so change start_time for 2nd appt\n        url = f\"{BASE_URL}/appointments/\"\n        appointment_payload_2 = {\n            \"patient_id\": patient[\"id\"],\n            \"doctor_id\": doctor[\"id\"],\n            \"appointment_date\": appointment_date,\n            \"start_time\": \"11:00\",\n            \"type\": \"SCHEDULED\"\n        }\n        resp = requests.post(url, json=appointment_payload_2, timeout=TIMEOUT)\n        resp.raise_for_status()\n        appointment2 = resp.json()\n\n        # Fetch QR code for first appointment digital check-in\n        qrcode_url_1 = f\"{BASE_URL}/appointments/{appointment1['id']}/qrcode/\"\n        resp_qr1 = requests.get(qrcode_url_1, timeout=TIMEOUT)\n        assert resp_qr1.status_code == 200\n        qr_code_data_1 = resp_qr1.json()\n        assert \"qr_code\" in qr_code_data_1 and qr_code_data_1[\"qr_code\"], \"QR code missing for appointment 1\"\n\n        # Fetch QR code for second appointment digital check-in\n        qrcode_url_2 = f\"{BASE_URL}/appointments/{appointment2['id']}/qrcode/\"\n        resp_qr2 = requests.get(qrcode_url_2, timeout=TIMEOUT)\n        assert resp_qr2.status_code == 200\n        qr_code_data_2 = resp_qr2.json()\n        assert \"qr_code\" in qr_code_data_2 and qr_code_data_2[\"qr_code\"], \"QR code missing for appointment 2\"\n\n        # Confirm QR codes are unique\n        assert qr_code_data_1[\"qr_code\"] != qr_code_data_2[\"qr_code\"], \"QR codes should be unique per appointment\"\n\n        # Check the QR codes are linked correctly by scanning back appointment info with digital check-in API\n        checkin_url_1 = f\"{BASE_URL}/digital_checkin/scan/\"\n        payload1 = {\"qr_code\": qr_code_data_1[\"qr_code\"]}\n        resp_checkin1 = requests.post(checkin_url_1, json=payload1, timeout=TIMEOUT)\n        assert resp_checkin1.status_code == 200\n        checkin_data1 = resp_checkin1.json()\n        assert checkin_data1[\"appointment_id\"] == appointment1[\"id\"]\n        assert checkin_data1[\"patient_id\"] == patient[\"id\"]\n        assert checkin_data1[\"doctor_id\"] == doctor[\"id\"]\n\n        payload2 = {\"qr_code\": qr_code_data_2[\"qr_code\"]}\n        resp_checkin2 = requests.post(checkin_url_1, json=payload2, timeout=TIMEOUT)\n        assert resp_checkin2.status_code == 200\n        checkin_data2 = resp_checkin2.json()\n        assert checkin_data2[\"appointment_id\"] == appointment2[\"id\"]\n        assert checkin_data2[\"patient_id\"] == patient[\"id\"]\n        assert checkin_data2[\"doctor_id\"] == doctor[\"id\"]\n\n    finally:\n        if appointment1:\n            delete_appointment(appointment1[\"id\"])\n        if appointment2:\n            delete_appointment(appointment2[\"id\"])\n        delete_patient(patient[\"id\"])\n        delete_doctor(doctor[\"id\"])\n\ntest_digital_checkin_qrcode_generation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 125, in <module>\n  File \"<string>\", line 60, in test_digital_checkin_qrcode_generation\n  File \"<string>\", line 16, in create_doctor\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:9000/doctors/\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-12T15:07:02.139Z",
    "modified": "2026-01-12T15:08:00.370Z"
  },
  {
    "projectId": "14d42bad-3783-4357-b5a2-b83f83c5dd91",
    "testId": "b4eea237-bc57-4fe6-883c-0cb85e2b83c0",
    "userId": "14b89418-40d1-70e8-88e4-c2f9631e0e84",
    "title": "TC004-real_time_queue_tracking",
    "description": "Validate the queue tracking API provides real-time updates on patient queue status and position, ensuring FIFO order management and notifications.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef create_doctor():\n    # Create a doctor profile with specialization and availability\n    doctor_data = {\n        \"name\": f\"Dr_{uuid.uuid4().hex[:8]}\",\n        \"email\": f\"dr{uuid.uuid4().hex[:8]}@clinic.com\",\n        \"specialization\": \"General\",\n        \"weekly_availability\": [\n            {\"day\": \"Monday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"},\n            {\"day\": \"Tuesday\", \"start_time\": \"09:00\", \"end_time\": \"17:00\"}\n        ]\n    }\n    resp = requests.post(f\"{BASE_URL}/api/doctors/\", json=doctor_data, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()['id']\n\ndef delete_doctor(doctor_id):\n    requests.delete(f\"{BASE_URL}/api/doctors/{doctor_id}/\", headers=HEADERS, timeout=TIMEOUT)\n\ndef create_patient():\n    # Create a patient profile with valid emergency contact\n    patient_data = {\n        \"name\": f\"Patient_{uuid.uuid4().hex[:8]}\",\n        \"email\": f\"patient{uuid.uuid4().hex[:8]}@example.com\",\n        \"emergency_contact\": \"0911234567\"\n    }\n    resp = requests.post(f\"{BASE_URL}/api/patients/\", json=patient_data, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()['id']\n\ndef delete_patient(patient_id):\n    requests.delete(f\"{BASE_URL}/api/patients/{patient_id}/\", headers=HEADERS, timeout=TIMEOUT)\n\ndef book_appointment(patient_id, doctor_id):\n    # Book a scheduled appointment for today in the future, simple valid appointment\n    appointment_data = {\n        \"patient_id\": patient_id,\n        \"doctor_id\": doctor_id,\n        \"appointment_date\": time.strftime(\"%Y-%m-%d\"),\n        \"start_time\": \"15:00\",\n        \"status\": \"SCHEDULED\"\n    }\n    resp = requests.post(f\"{BASE_URL}/api/appointments/\", json=appointment_data, headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()['id']\n\ndef cancel_appointment(appointment_id):\n    requests.delete(f\"{BASE_URL}/api/appointments/{appointment_id}/\", headers=HEADERS, timeout=TIMEOUT)\n\ndef checkin_appointment(appointment_id):\n    # Endpoint to perform digital check-in for walk-in or scheduled appointments\n    resp = requests.post(f\"{BASE_URL}/api/appointments/{appointment_id}/checkin/\", headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef get_queue_status(doctor_id):\n    # Get real-time queue tracking info for a doctor's patients\n    resp = requests.get(f\"{BASE_URL}/api/queues/{doctor_id}/\", headers=HEADERS, timeout=TIMEOUT)\n    resp.raise_for_status()\n    return resp.json()\n\ndef test_real_time_queue_tracking():\n    doctor_id = None\n    patient1_id = None\n    patient2_id = None\n    appointment1_id = None\n    appointment2_id = None\n    try:\n        # Create doctor and patients\n        doctor_id = create_doctor()\n        patient1_id = create_patient()\n        patient2_id = create_patient()\n\n        # Book two appointments for same doctor to test FIFO queue behavior\n        appointment1_id = book_appointment(patient1_id, doctor_id)\n        appointment2_id = book_appointment(patient2_id, doctor_id)\n\n        # Check initial queue status: both patients in queue, patient1 ahead of patient2 (FIFO)\n        queue_status = get_queue_status(doctor_id)\n        assert isinstance(queue_status, dict), \"Queue status response must be a dict\"\n        queue_list = queue_status.get(\"queue\")\n        assert isinstance(queue_list, list), \"Queue list must be a list\"\n        # Expect at least two patients in queue and patient1 position before patient2\n        positions = {entry[\"appointment_id\"]: entry[\"position\"] for entry in queue_list}\n        assert appointment1_id in positions, \"Patient 1 appointment not in queue\"\n        assert appointment2_id in positions, \"Patient 2 appointment not in queue\"\n        assert positions[appointment1_id] < positions[appointment2_id], \"FIFO order violated in queue\"\n\n        # Simulate patient1 check-in to update status to CHECKED_IN\n        checkin_resp = checkin_appointment(appointment1_id)\n        assert checkin_resp.get(\"status\") == \"CHECKED_IN\", \"Patient1 should be checked-in\"\n\n        # Queue should reflect update: patient1 now CHECKED_IN and position 1\n        queue_status_updated = get_queue_status(doctor_id)\n        queue_list_updated = queue_status_updated.get(\"queue\")\n        patient1_entry = next((q for q in queue_list_updated if q[\"appointment_id\"] == appointment1_id), None)\n        patient2_entry = next((q for q in queue_list_updated if q[\"appointment_id\"] == appointment2_id), None)\n        assert patient1_entry is not None and patient2_entry is not None, \"Both patients should be in updated queue\"\n        # Patient1 position should remain ahead in queue\n        assert patient1_entry[\"position\"] < patient2_entry[\"position\"], \"Queue order not maintained after check-in\"\n        assert patient1_entry[\"status\"] == \"CHECKED_IN\", \"Patient1 status should be CHECKED_IN\"\n\n        # Simulate patient1 consultation start and end (status changes)\n        resp_start = requests.post(f\"{BASE_URL}/api/appointments/{appointment1_id}/start_consultation/\", headers=HEADERS, timeout=TIMEOUT)\n        resp_start.raise_for_status()\n        resp_end = requests.post(f\"{BASE_URL}/api/appointments/{appointment1_id}/end_consultation/\", headers=HEADERS, timeout=TIMEOUT)\n        resp_end.raise_for_status()\n\n        # Queue updates after patient1 consultation ended, patient1 should be COMPLETED and patient2 moves up in position\n        queue_status_post_consult = get_queue_status(doctor_id)\n        queue_list_post = queue_status_post_consult.get(\"queue\")\n\n        # Patient1 should no longer be active in queue or have status COMPLETED\n        patient1_post = next((q for q in queue_list_post if q[\"appointment_id\"] == appointment1_id), None)\n        patient2_post = next((q for q in queue_list_post if q[\"appointment_id\"] == appointment2_id), None)\n        \n        if patient1_post:\n            assert patient1_post[\"status\"] == \"COMPLETED\", \"Patient1 status should be COMPLETED after consultation\"\n        # Patient2 should have position 1 now\n        assert patient2_post is not None, \"Patient2 must be in queue after patient1 consultation ends\"\n        assert patient2_post[\"position\"] == 1, \"Patient2 position should be updated to 1 after patient1 consultation ends\"\n\n        # Check notification fields exist for queue entries (simulate notifications)\n        for entry in queue_list_post:\n            assert \"notifications\" in entry, \"Queue entry must include notification info\"\n            notifications = entry[\"notifications\"]\n            assert isinstance(notifications, dict), \"Notifications must be a dictionary\"\n            # Should at least have notification channels listed, e.g. in_app, email, sms\n            for channel in ['in_app', 'email', 'sms']:\n                assert channel in notifications, f\"Notification channel '{channel}' missing\"\n                assert isinstance(notifications[channel], bool), f\"Notification channel '{channel}' should be boolean\"\n\n    finally:\n        # Cleanup all created resources\n        if appointment1_id:\n            cancel_appointment(appointment1_id)\n        if appointment2_id:\n            cancel_appointment(appointment2_id)\n        if patient1_id:\n            delete_patient(patient1_id)\n        if patient2_id:\n            delete_patient(patient2_id)\n        if doctor_id:\n            delete_doctor(doctor_id)\n\ntest_real_time_queue_tracking()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 153, in <module>\n  File \"<string>\", line 77, in test_real_time_queue_tracking\n  File \"<string>\", line 21, in create_doctor\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:9000/api/doctors/\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-12T15:07:02.151Z",
    "modified": "2026-01-12T15:07:52.976Z"
  },
  {
    "projectId": "14d42bad-3783-4357-b5a2-b83f83c5dd91",
    "testId": "9d070824-1030-43c3-a0a3-320519db2673",
    "userId": "14b89418-40d1-70e8-88e4-c2f9631e0e84",
    "title": "TC005-user_authentication_and_role_access",
    "description": "Test the user login and multi-role authentication API to ensure secure access control for patients, doctors, nurses, and admins with appropriate permissions.",
    "code": "import requests\nfrom requests.exceptions import RequestException\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\n\n# Sample users with different roles for testing login and access\nUSERS = {\n    \"patient\": {\"email\": \"patient@example.com\", \"password\": \"patientpass\"},\n    \"doctor\": {\"email\": \"doctor@example.com\", \"password\": \"doctorpass\"},\n    \"nurse\": {\"email\": \"nurse@example.com\", \"password\": \"nursepass\"},\n    \"admin\": {\"email\": \"admin@example.com\", \"password\": \"adminpass\"}\n}\n\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\",\n}\n\ndef test_user_authentication_and_role_access():\n    tokens = {}\n    try:\n        # LOGIN for all user roles\n        for role, creds in USERS.items():\n            login_url = f\"{BASE_URL}/api/accounts/login/\"\n            payload = {\n                \"email\": creds[\"email\"],\n                \"password\": creds[\"password\"]\n            }\n            response = requests.post(login_url, json=payload, headers=HEADERS, timeout=TIMEOUT)\n            assert response.status_code == 200, f\"Login failed for {role} with status {response.status_code}\"\n            data = response.json()\n            assert \"token\" in data and isinstance(data[\"token\"], str) and len(data[\"token\"]) > 0, f\"No token returned for {role}\"\n            tokens[role] = data[\"token\"]\n\n        # ACCESS CONTROL TESTS\n        # Mapping roles to their expected accessible endpoints and forbidden endpoints\n        access_tests = {\n            \"patient\": {\n                \"allowed\": [\n                    f\"{BASE_URL}/api/patients/profile/\",\n                    f\"{BASE_URL}/api/appointments/book/\",\n                ],\n                \"forbidden\": [\n                    f\"{BASE_URL}/api/admin/users/\",\n                    f\"{BASE_URL}/api/doctors/schedule/\",\n                ],\n            },\n            \"doctor\": {\n                \"allowed\": [\n                    f\"{BASE_URL}/api/doctors/schedule/\",\n                    f\"{BASE_URL}/api/appointments/my/\",\n                ],\n                \"forbidden\": [\n                    f\"{BASE_URL}/api/admin/users/\",\n                    f\"{BASE_URL}/api/patients/profile/\",\n                ],\n            },\n            \"nurse\": {\n                \"allowed\": [\n                    f\"{BASE_URL}/api/queues/manage/\",\n                    f\"{BASE_URL}/api/appointments/in_progress/\",\n                ],\n                \"forbidden\": [\n                    f\"{BASE_URL}/api/admin/users/\",\n                    f\"{BASE_URL}/api/doctors/schedule/\",\n                ],\n            },\n            \"admin\": {\n                \"allowed\": [\n                    f\"{BASE_URL}/api/admin/users/\",\n                    f\"{BASE_URL}/api/announcements/broadcast/\",\n                ],\n                \"forbidden\": [\n                    f\"{BASE_URL}/api/patients/profile/\",\n                    f\"{BASE_URL}/api/appointments/book/\",\n                ],\n            },\n        }\n\n        for role, perms in access_tests.items():\n            token = tokens[role]\n            auth_headers = HEADERS.copy()\n            auth_headers[\"Authorization\"] = f\"Bearer {token}\"\n\n            # Check allowed endpoints\n            for url in perms[\"allowed\"]:\n                try:\n                    resp = requests.get(url, headers=auth_headers, timeout=TIMEOUT)\n                    assert resp.status_code in (200, 204), f\"{role} should have access to {url} but got {resp.status_code}\"\n                except RequestException as e:\n                    assert False, f\"RequestException accessing {url} as {role}: {e}\"\n\n            # Check forbidden endpoints\n            for url in perms[\"forbidden\"]:\n                try:\n                    resp = requests.get(url, headers=auth_headers, timeout=TIMEOUT)\n                    assert resp.status_code in (401, 403), f\"{role} should not have access to {url} but got {resp.status_code}\"\n                except RequestException as e:\n                    assert False, f\"RequestException accessing {url} as {role}: {e}\"\n\n    except RequestException as err:\n        assert False, f\"RequestException during test execution: {err}\"\n\n# Run the test function\ntest_user_authentication_and_role_access()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 106, in <module>\n  File \"<string>\", line 31, in test_user_authentication_and_role_access\nAssertionError: Login failed for patient with status 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-12T15:07:02.167Z",
    "modified": "2026-01-12T15:08:33.173Z"
  },
  {
    "projectId": "14d42bad-3783-4357-b5a2-b83f83c5dd91",
    "testId": "230748ae-614a-4577-b1dd-6ccab37614bb",
    "userId": "14b89418-40d1-70e8-88e4-c2f9631e0e84",
    "title": "TC006-appointment_modification_and_cancellation",
    "description": "Verify the appointment modification and cancellation API correctly updates appointment status and enforces validation rules.",
    "code": "import requests\nimport uuid\nfrom datetime import datetime, timedelta\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef create_doctor():\n    payload = {\n        \"name\": \"Dr. Test\",\n        \"specialization\": \"General\",\n        \"email\": f\"drtest{uuid.uuid4().hex[:8]}@clinic.test\"\n    }\n    response = requests.post(f\"{BASE_URL}/api/doctors/\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n    response.raise_for_status()\n    return response.json()\n\ndef delete_doctor(doctor_id):\n    requests.delete(f\"{BASE_URL}/api/doctors/{doctor_id}/\", timeout=TIMEOUT)\n\ndef create_patient():\n    payload = {\n        \"name\": \"Patient Test\",\n        \"email\": f\"patienttest{uuid.uuid4().hex[:8]}@clinic.test\",\n        \"emergency_contact\": \"0911234567\"\n    }\n    response = requests.post(f\"{BASE_URL}/api/patients/\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n    response.raise_for_status()\n    return response.json()\n\ndef delete_patient(patient_id):\n    requests.delete(f\"{BASE_URL}/api/patients/{patient_id}/\", timeout=TIMEOUT)\n\ndef create_appointment(patient_id, doctor_id, appointment_date, start_time, status=\"SCHEDULED\"):\n    payload = {\n        \"patient_id\": patient_id,\n        \"doctor_id\": doctor_id,\n        \"appointment_date\": appointment_date,\n        \"start_time\": start_time,\n        \"status\": status,\n        \"type\": \"scheduled\"\n    }\n    response = requests.post(f\"{BASE_URL}/api/appointments/\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n    return response\n\ndef modify_appointment_status(appointment_id, new_status):\n    payload = {\"status\": new_status}\n    response = requests.patch(f\"{BASE_URL}/api/appointments/{appointment_id}/\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n    return response\n\ndef cancel_appointment(appointment_id):\n    payload = {\"status\": \"CANCELLED\"}\n    response = requests.patch(f\"{BASE_URL}/api/appointments/{appointment_id}/\", json=payload, headers=HEADERS, timeout=TIMEOUT)\n    return response\n\ndef test_appointment_modification_and_cancellation():\n    doctor = patient = appointment = None\n    try:\n        # Create doctor and patient resources\n        doctor = create_doctor()\n        patient = create_patient()\n\n        # Appointment date/time - a date in the future with valid time\n        appointment_date = (datetime.now() + timedelta(days=3)).date().isoformat()\n        start_time = \"10:00\"\n\n        # Create a scheduled appointment\n        create_resp = create_appointment(patient[\"id\"], doctor[\"id\"], appointment_date, start_time)\n        assert create_resp.status_code == 201, f\"Failed to create appointment: {create_resp.text}\"\n        appointment = create_resp.json()\n        assert appointment[\"status\"] == \"SCHEDULED\", \"New appointments must start with SCHEDULED status.\"\n\n        appointment_id = appointment[\"id\"]\n\n        # Modify appointment status to IN_PROGRESS (valid modification)\n        mod_resp = modify_appointment_status(appointment_id, \"IN_PROGRESS\")\n        assert mod_resp.status_code == 200, f\"Failed to modify appointment status: {mod_resp.text}\"\n        mod_appt = mod_resp.json()\n        assert mod_appt[\"status\"] == \"IN_PROGRESS\", \"Appointment status should be updated to IN_PROGRESS.\"\n\n        # Attempt invalid status update - e.g., setting status to invalid string\n        invalid_resp = modify_appointment_status(appointment_id, \"INVALID_STATUS\")\n        assert invalid_resp.status_code == 400, \"Invalid status update should be rejected with 400 error.\"\n\n        # Attempt modification with missing required fields (patch with empty body)\n        empty_resp = requests.patch(f\"{BASE_URL}/api/appointments/{appointment_id}/\", json={}, headers=HEADERS, timeout=TIMEOUT)\n        # Depending on API design, empty patch may return 200 or 400 - check response\n        assert empty_resp.status_code in (200, 400), \"Empty PATCH request should be handled gracefully.\"\n\n        # Cancel the appointment\n        cancel_resp = cancel_appointment(appointment_id)\n        assert cancel_resp.status_code == 200, f\"Failed to cancel appointment: {cancel_resp.text}\"\n        cancelled_appt = cancel_resp.json()\n        assert cancelled_appt[\"status\"] == \"CANCELLED\", \"Appointment status should be updated to CANCELLED.\"\n\n        # Try to modify a cancelled appointment (should reject if business rule forbids)\n        mod_after_cancel_resp = modify_appointment_status(appointment_id, \"SCHEDULED\")\n        # Either 400 or 409 conflict expected if modification of cancelled appointment forbidden\n        assert mod_after_cancel_resp.status_code in (400, 409), \"Modification of cancelled appointment should be forbidden.\"\n\n        # Validation test: attempt to modify appointment_date to past date (assuming allowed on modification)\n        past_date = (datetime.now() - timedelta(days=1)).date().isoformat()\n        patch_payload = {\"appointment_date\": past_date}\n        invalid_date_resp = requests.patch(f\"{BASE_URL}/api/appointments/{appointment_id}/\", json=patch_payload, headers=HEADERS, timeout=TIMEOUT)\n        # Validate the system rejects past date modification\n        assert invalid_date_resp.status_code == 400, \"Should reject modifying appointment to a past date.\"\n\n    finally:\n        # Clean up created appointment if exists\n        if appointment and \"id\" in appointment:\n            requests.delete(f\"{BASE_URL}/api/appointments/{appointment['id']}/\", timeout=TIMEOUT)\n        # Clean up doctor and patient\n        if doctor and \"id\" in doctor:\n            delete_doctor(doctor[\"id\"])\n        if patient and \"id\" in patient:\n            delete_patient(patient[\"id\"])\n\ntest_appointment_modification_and_cancellation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 119, in <module>\n  File \"<string>\", line 61, in test_appointment_modification_and_cancellation\n  File \"<string>\", line 16, in create_doctor\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:9000/api/doctors/\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-12T15:07:02.179Z",
    "modified": "2026-01-12T15:08:19.335Z"
  },
  {
    "projectId": "14d42bad-3783-4357-b5a2-b83f83c5dd91",
    "testId": "affba054-e430-4489-85c0-3fcac52c20c1",
    "userId": "14b89418-40d1-70e8-88e4-c2f9631e0e84",
    "title": "TC007-emergency_contact_validation",
    "description": "Test patient registration and profile update APIs to validate emergency contact numbers start with 091, 092, 093, or 094 followed by 7 digits.",
    "code": "import requests\nimport re\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\nEMERGENCY_CONTACT_REGEX = r\"^(091|092|093|094)\\d{7}$\"\n\ndef test_emergency_contact_validation():\n    \"\"\"\n    Test patient registration and update APIs to validate emergency contact field format:\n    Must start with 091, 092, 093, or 094 followed by exactly 7 digits.\n    \"\"\"\n\n    patient_create_url = f\"{BASE_URL}/accounts/register/\"\n    patient_detail_url_template = f\"{BASE_URL}/patients/{{patient_id}}/\"\n\n    def is_valid_emergency_contact(number: str) -> bool:\n        return bool(re.match(EMERGENCY_CONTACT_REGEX, number))\n\n    # Prepare valid patient registration data with valid emergency contact\n    valid_patient_data = {\n        \"email\": \"testuser_emc@example.com\",\n        \"password\": \"StrongPassw0rd!\",\n        \"first_name\": \"Test\",\n        \"last_name\": \"User\",\n        \"emergency_contact\": \"0911234567\",\n        \"date_of_birth\": \"1990-01-01\"\n    }\n\n    # Prepare invalid emergency contacts to test negative cases\n    invalid_contacts = [\n        \"\",                      # empty\n        \"0901234567\",            # bad prefix\n        \"0951234567\",            # bad prefix\n        \"091123456\",             # too short\n        \"09112345678\",           # too long\n        \"09112345a7\",            # non-digit character\n        \"0012345678\"             # wrong prefix\n    ]\n\n    # 1. Create patient with valid emergency contact - expect success (201 Created)\n    patient_id = None\n    try:\n        resp_create = requests.post(patient_create_url, json=valid_patient_data, headers=HEADERS, timeout=TIMEOUT)\n    except Exception as e:\n        assert False, f\"Exception during patient creation with valid data: {e}\"\n\n    assert resp_create.status_code == 201, f\"Failed to create patient with valid emergency contact. Status: {resp_create.status_code}, Response: {resp_create.text}\"\n\n    patient_created = resp_create.json()\n    patient_id = patient_created.get(\"id\")\n    assert patient_id, \"Created patient response missing 'id'.\"\n\n    try:\n        # Validate the emergency_contact field in response matches regex\n        ec = patient_created.get(\"emergency_contact\")\n        assert ec is not None, \"emergency_contact field missing in create response.\"\n        assert is_valid_emergency_contact(ec), f\"Returned emergency_contact '{ec}' is invalid.\"\n\n        # 2. Attempt to update the patient with each invalid emergency contact - expect failure (400 Bad Request)\n        for invalid_contact in invalid_contacts:\n            update_payload = {\"emergency_contact\": invalid_contact}\n            try:\n                resp_update = requests.put(patient_detail_url_template.format(patient_id=patient_id),\n                                           json=update_payload, headers=HEADERS, timeout=TIMEOUT)\n            except Exception as e:\n                assert False, f\"Exception during patient update with invalid emergency_contact '{invalid_contact}': {e}\"\n\n            # Expect 400 Bad Request due to validation error\n            assert resp_update.status_code == 400, (\n                f\"Updating emergency_contact with invalid value '{invalid_contact}' did NOT return 400. \"\n                f\"Status: {resp_update.status_code}, Response: {resp_update.text}\"\n            )\n\n        # 3. Update the patient with another valid emergency contact - expect success\n        valid_update_contact = \"0947654321\"\n        update_payload = {\"emergency_contact\": valid_update_contact}\n        resp_update_valid = requests.put(patient_detail_url_template.format(patient_id=patient_id),\n                                        json=update_payload, headers=HEADERS, timeout=TIMEOUT)\n        assert resp_update_valid.status_code == 200, (\n            f\"Updating emergency_contact with valid value '{valid_update_contact}' failed. \"\n            f\"Status: {resp_update_valid.status_code}, Response: {resp_update_valid.text}\"\n        )\n        updated_patient = resp_update_valid.json()\n        updated_ec = updated_patient.get(\"emergency_contact\")\n        assert updated_ec == valid_update_contact, \"Emergency contact was not updated correctly.\"\n\n    finally:\n        # Cleanup: delete the created patient\n        if patient_id:\n            try:\n                requests.delete(patient_detail_url_template.format(patient_id=patient_id), headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_emergency_contact_validation()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 97, in <module>\n  File \"<string>\", line 49, in test_emergency_contact_validation\nAssertionError: Failed to create patient with valid emergency contact. Status: 403, Response: <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n  <meta name=\"robots\" content=\"NONE,NOARCHIVE\">\n  <title>403 Forbidden</title>\n  <style type=\"text/css\">\n    html * { padding:0; margin:0; }\n    body * { padding:10px 20px; }\n    body * * { padding:0; }\n    body { font:small sans-serif; background:#eee; color:#000; }\n    body>div { border-bottom:1px solid #ddd; }\n    h1 { font-weight:normal; margin-bottom:.4em; }\n    h1 span { font-size:60%; color:#666; font-weight:normal; }\n    #info { background:#f6f6f6; }\n    #info ul { margin: 0.5em 4em; }\n    #info p, #summary p { padding-top:10px; }\n    #summary { background: #ffc; }\n    #explanation { background:#eee; border-bottom: 0px none; }\n  </style>\n</head>\n<body>\n<div id=\"summary\">\n  <h1>Forbidden <span>(403)</span></h1>\n  <p>CSRF verification failed. Request aborted.</p>\n\n\n  <p>You are seeing this message because this site requires a CSRF cookie when submitting forms. This cookie is required for security reasons, to ensure that your browser is not being hijacked by third parties.</p>\n  <p>If you have configured your browser to disable cookies, please re-enable them, at least for this site, or for “same-origin” requests.</p>\n\n</div>\n\n<div id=\"info\">\n  <h2>Help</h2>\n    \n    <p>Reason given for failure:</p>\n    <pre>\n    CSRF cookie not set.\n    </pre>\n    \n\n  <p>In general, this can occur when there is a genuine Cross Site Request Forgery, or when\n  <a\n  href=\"https://docs.djangoproject.com/en/5.0/ref/csrf/\">Django’s\n  CSRF mechanism</a> has not been used correctly.  For POST forms, you need to\n  ensure:</p>\n\n  <ul>\n    <li>Your browser is accepting cookies.</li>\n\n    <li>The view function passes a <code>request</code> to the template’s <a\n    href=\"https://docs.djangoproject.com/en/dev/topics/templates/#django.template.backends.base.Template.render\"><code>render</code></a>\n    method.</li>\n\n    <li>In the template, there is a <code>{% csrf_token\n    %}</code> template tag inside each POST form that\n    targets an internal URL.</li>\n\n    <li>If you are not using <code>CsrfViewMiddleware</code>, then you must use\n    <code>csrf_protect</code> on any views that use the <code>csrf_token</code>\n    template tag, as well as those that accept the POST data.</li>\n\n    <li>The form has a valid CSRF token. After logging in in another browser\n    tab or hitting the back button after a login, you may need to reload the\n    page with the form, because the token is rotated after a login.</li>\n  </ul>\n\n  <p>You’re seeing the help section of this page because you have <code>DEBUG =\n  True</code> in your Django settings file. Change that to <code>False</code>,\n  and only the initial error message will be displayed.  </p>\n\n  <p>You can customize this page using the CSRF_FAILURE_VIEW setting.</p>\n</div>\n\n</body>\n</html>\n\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-12T15:07:02.190Z",
    "modified": "2026-01-12T15:08:38.803Z"
  },
  {
    "projectId": "14d42bad-3783-4357-b5a2-b83f83c5dd91",
    "testId": "adaec124-c08f-4b89-9172-516acce2e656",
    "userId": "14b89418-40d1-70e8-88e4-c2f9631e0e84",
    "title": "TC008-notification_delivery_reliability",
    "description": "Test the notification API to ensure reliable delivery with retries on failure and support for multi-channel delivery including in-app, email, and SMS.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:9000\"\nNOTIFICATIONS_ENDPOINT = f\"{BASE_URL}/api/notifications/\"\nAUTH_TOKEN = \"Bearer your_test_auth_token_here\"  # Replace with valid token if needed\nHEADERS = {\n    \"Authorization\": AUTH_TOKEN,\n    \"Content-Type\": \"application/json\",\n    \"Accept\": \"application/json\"\n}\nTIMEOUT = 30\n\ndef test_notification_delivery_reliability():\n    \"\"\"\n    Test the notification API for reliable delivery with retries on failure\n    and multi-channel support including in-app, email, and SMS.\n    \"\"\"\n    notification_payload = {\n        \"recipient_id\": 1,  # Assume existing user ID; in a real test, create user and use its ID\n        \"channels\": [\"in-app\", \"email\", \"sms\"],\n        \"title\": \"Test Notification Delivery\",\n        \"message\": \"This is a test notification to verify delivery reliability.\",\n        \"metadata\": {\n            \"appointment_id\": 42,\n            \"priority\": \"high\"\n        }\n    }\n    \n    max_retries = 3\n    retry_delay_seconds = 2\n    response = None\n\n    # Attempt sending notification with retry logic for failure scenarios\n    for attempt in range(1, max_retries + 1):\n        try:\n            response = requests.post(NOTIFICATIONS_ENDPOINT, json=notification_payload, headers=HEADERS, timeout=TIMEOUT)\n            if response.status_code == 200 or response.status_code == 201:\n                break  # Success\n        except requests.RequestException:\n            pass  # Swallow exception and retry\n\n        if attempt < max_retries:\n            time.sleep(retry_delay_seconds)\n    else:\n        assert False, f\"Notification sending failed after {max_retries} attempts.\"\n\n    # Validate response structure and content\n    assert response is not None\n    assert response.status_code in (200, 201)\n    resp_json = response.json()\n    assert \"notification_id\" in resp_json\n    notification_id = resp_json[\"notification_id\"]\n    assert isinstance(notification_id, int)\n    assert resp_json.get(\"status\") in [\"sent\", \"queued\", \"delivered\", \"processing\"]\n\n    # Verify multi-channel delivery status\n    delivery_status = resp_json.get(\"delivery_status\")\n    assert delivery_status is not None\n    for channel in notification_payload[\"channels\"]:\n        assert channel in delivery_status\n        # Each channel should have a status indicating success or retry\n        channel_status = delivery_status[channel]\n        assert channel_status in [\"pending\", \"sent\", \"failed\", \"retrying\", \"delivered\"]\n\n    # Optionally, poll the notification status API to confirm final delivery state\n    status_url = f\"{NOTIFICATIONS_ENDPOINT}{notification_id}/status/\"\n    final_status = None\n    for _ in range(5):\n        try:\n            status_response = requests.get(status_url, headers=HEADERS, timeout=TIMEOUT)\n            if status_response.status_code == 200:\n                status_json = status_response.json()\n                final_status = status_json.get(\"final_status\")\n                if final_status in [\"delivered\", \"failed\"]:\n                    break\n        except requests.RequestException:\n            pass\n        time.sleep(1)\n    assert final_status in [\"delivered\", \"failed\"]\n\ntest_notification_delivery_reliability()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 82, in <module>\n  File \"<string>\", line 46, in test_notification_delivery_reliability\nAssertionError: Notification sending failed after 3 attempts.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-12T15:07:02.197Z",
    "modified": "2026-01-12T15:08:06.254Z"
  },
  {
    "projectId": "14d42bad-3783-4357-b5a2-b83f83c5dd91",
    "testId": "08237661-b8ed-4032-bec1-e0fdb76aa528",
    "userId": "14b89418-40d1-70e8-88e4-c2f9631e0e84",
    "title": "TC009-patient_feedback_submission",
    "description": "Verify the patient feedback API allows submission of feedback and ratings for doctors and clinic services, ensuring required fields are validated.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\n\ndef test_patient_feedback_submission():\n    headers = {\n        \"Content-Type\": \"application/json\",\n    }\n\n    feedback_url = f\"{BASE_URL}/api/patients/feedback/\"\n\n    # Use fixed patient_id and doctor_id since creation endpoints do not exist or are inaccessible\n    patient_id = 1\n    doctor_id = 1\n    feedback_id = None\n\n    try:\n        # 1) Test successful feedback submission with all required fields\n        feedback_payload = {\n            \"patient_id\": patient_id,\n            \"doctor_id\": doctor_id,\n            \"rating\": 4,\n            \"service_rating\": 5,\n            \"feedback_text\": \"The doctor provided excellent care and the clinic was very efficient.\"\n        }\n\n        feedback_resp = requests.post(feedback_url, json=feedback_payload, headers=headers, timeout=TIMEOUT)\n        assert feedback_resp.status_code == 201, f\"Failed to submit feedback: {feedback_resp.text}\"\n        feedback_data = feedback_resp.json()\n        feedback_id = feedback_data.get(\"id\")\n        assert feedback_id is not None, \"Feedback ID not returned\"\n        # Validate returned feedback data matches input where applicable\n        assert feedback_data.get(\"patient_id\") == patient_id\n        assert feedback_data.get(\"doctor_id\") == doctor_id\n        assert feedback_data.get(\"rating\") == feedback_payload[\"rating\"]\n        assert feedback_data.get(\"service_rating\") == feedback_payload[\"service_rating\"]\n        assert feedback_data.get(\"feedback_text\") == feedback_payload[\"feedback_text\"]\n\n        # 2) Test validation: missing required field patient_id\n        invalid_payload_1 = {\n            \"doctor_id\": doctor_id,\n            \"rating\": 4,\n            \"service_rating\": 5,\n            \"feedback_text\": \"Some feedback\"\n        }\n        resp_invalid_1 = requests.post(feedback_url, json=invalid_payload_1, headers=headers, timeout=TIMEOUT)\n        assert resp_invalid_1.status_code == 400, \"Expected 400 error for missing patient_id\"\n        assert \"patient_id\" in resp_invalid_1.text.lower()\n\n        # 3) Test validation: missing rating\n        invalid_payload_2 = {\n            \"patient_id\": patient_id,\n            \"doctor_id\": doctor_id,\n            \"service_rating\": 5,\n            \"feedback_text\": \"Some feedback\"\n        }\n        resp_invalid_2 = requests.post(feedback_url, json=invalid_payload_2, headers=headers, timeout=TIMEOUT)\n        assert resp_invalid_2.status_code == 400, \"Expected 400 error for missing rating\"\n        assert \"rating\" in resp_invalid_2.text.lower()\n\n        # 4) Test validation: rating out of allowed range (e.g., 0)\n        invalid_payload_3 = {\n            \"patient_id\": patient_id,\n            \"doctor_id\": doctor_id,\n            \"rating\": 0,\n            \"service_rating\": 5,\n            \"feedback_text\": \"Invalid rating low\"\n        }\n        resp_invalid_3 = requests.post(feedback_url, json=invalid_payload_3, headers=headers, timeout=TIMEOUT)\n        assert resp_invalid_3.status_code == 400, \"Expected 400 error for rating out of range\"\n        assert \"rating\" in resp_invalid_3.text.lower()\n\n        # 5) Test validation: rating out of allowed range (e.g., 6)\n        invalid_payload_4 = {\n            \"patient_id\": patient_id,\n            \"doctor_id\": doctor_id,\n            \"rating\": 6,\n            \"service_rating\": 5,\n            \"feedback_text\": \"Invalid rating high\"\n        }\n        resp_invalid_4 = requests.post(feedback_url, json=invalid_payload_4, headers=headers, timeout=TIMEOUT)\n        assert resp_invalid_4.status_code == 400, \"Expected 400 error for rating out of range\"\n        assert \"rating\" in resp_invalid_4.text.lower()\n\n        # 6) Test validation: missing service_rating\n        invalid_payload_5 = {\n            \"patient_id\": patient_id,\n            \"doctor_id\": doctor_id,\n            \"rating\": 4,\n            \"feedback_text\": \"Missing service rating\"\n        }\n        resp_invalid_5 = requests.post(feedback_url, json=invalid_payload_5, headers=headers, timeout=TIMEOUT)\n        assert resp_invalid_5.status_code == 400, \"Expected 400 error for missing service_rating\"\n        assert \"service_rating\" in resp_invalid_5.text.lower()\n\n        # 7) Test validation: missing feedback_text (if required)\n        invalid_payload_6 = {\n            \"patient_id\": patient_id,\n            \"doctor_id\": doctor_id,\n            \"rating\": 4,\n            \"service_rating\": 5,\n        }\n        resp_invalid_6 = requests.post(feedback_url, json=invalid_payload_6, headers=headers, timeout=TIMEOUT)\n        # Assuming feedback_text is required, expect 400; if optional, expect success\n        # We'll assert 400 if feedback_text is required\n        assert resp_invalid_6.status_code in (400, 201), \"Unexpected status code for missing feedback_text\"\n        if resp_invalid_6.status_code == 400:\n            assert \"feedback_text\" in resp_invalid_6.text.lower()\n\n    finally:\n        # Cleanup: delete created feedback if ID available\n        if feedback_id:\n            feedback_del_url = f\"{feedback_url}{feedback_id}/\"\n            try:\n                requests.delete(feedback_del_url, headers=headers, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_patient_feedback_submission()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 120, in <module>\n  File \"<string>\", line 29, in test_patient_feedback_submission\nAssertionError: Failed to submit feedback: <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html; charset=utf-8\">\n  <title>Page not found at /api/patients/feedback/</title>\n  <meta name=\"robots\" content=\"NONE,NOARCHIVE\">\n  <style type=\"text/css\">\n    html * { padding:0; margin:0; }\n    body * { padding:10px 20px; }\n    body * * { padding:0; }\n    body { font:small sans-serif; background:#eee; color:#000; }\n    body>div { border-bottom:1px solid #ddd; }\n    h1 { font-weight:normal; margin-bottom:.4em; }\n    h1 span { font-size:60%; color:#666; font-weight:normal; }\n    table { border:none; border-collapse: collapse; width:100%; }\n    td, th { vertical-align:top; padding:2px 3px; }\n    th { width:12em; text-align:right; color:#666; padding-right:.5em; }\n    #info { background:#f6f6f6; }\n    #info ol { margin: 0.5em 4em; }\n    #info ol li { font-family: monospace; }\n    #summary { background: #ffc; }\n    #explanation { background:#eee; border-bottom: 0px none; }\n    pre.exception_value { font-family: sans-serif; color: #575757; font-size: 1.5em; margin: 10px 0 10px 0; }\n  </style>\n</head>\n<body>\n  <div id=\"summary\">\n    <h1>Page not found <span>(404)</span></h1>\n    \n    <table class=\"meta\">\n      <tr>\n        <th>Request Method:</th>\n        <td>POST</td>\n      </tr>\n      <tr>\n        <th>Request URL:</th>\n        <td>http://localhost:9000/api/patients/feedback/</td>\n      </tr>\n      \n    </table>\n  </div>\n  <div id=\"info\">\n    \n      <p>\n      Using the URLconf defined in <code>caqm_project.urls</code>,\n      Django tried these URL patterns, in this order:\n      </p>\n      <ol>\n        \n          <li>\n            \n                admin/\n                \n            \n          </li>\n        \n          <li>\n            \n                accounts/\n                \n            \n          </li>\n        \n          <li>\n            \n                admins/\n                \n            \n          </li>\n        \n          <li>\n            \n                appointments/\n                \n            \n          </li>\n        \n          <li>\n            \n                patients/\n                \n            \n          </li>\n        \n          <li>\n            \n                doctors/\n                \n            \n          </li>\n        \n          <li>\n            \n                queues/\n                \n            \n          </li>\n        \n          <li>\n            \n                nurses/\n                \n            \n          </li>\n        \n          <li>\n            \n                \n                \n            \n          </li>\n        \n          <li>\n            \n                ^static/(?P&lt;path&gt;.*)$\n                \n            \n          </li>\n        \n          <li>\n            \n                ^media/(?P&lt;path&gt;.*)$\n                \n            \n          </li>\n        \n      </ol>\n      <p>\n        \n          The current path, <code>api/patients/feedback/</code>,\n        \n        didn’t match any of these.\n      </p>\n    \n  </div>\n\n  <div id=\"explanation\">\n    <p>\n      You’re seeing this error because you have <code>DEBUG = True</code> in\n      your Django settings file. Change that to <code>False</code>, and Django\n      will display a standard 404 page.\n    </p>\n  </div>\n</body>\n</html>\n\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-12T15:07:02.217Z",
    "modified": "2026-01-12T15:08:54.183Z"
  },
  {
    "projectId": "14d42bad-3783-4357-b5a2-b83f83c5dd91",
    "testId": "2a402d9f-e324-4c48-ba20-e1bc6f6891a2",
    "userId": "14b89418-40d1-70e8-88e4-c2f9631e0e84",
    "title": "TC010-admin_announcement_broadcast",
    "description": "Test the admin announcement API to ensure admins can broadcast important news to users and notifications are delivered properly.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:9000\"\nTIMEOUT = 30\n\n# Admin credentials for authentication - adjust as needed\nADMIN_USERNAME = \"admin\"\nADMIN_PASSWORD = \"adminpassword\"\n\ndef get_admin_token():\n    \"\"\"\n    Authenticate as admin to get a JWT token.\n    Adjusted endpoint to '/api/token/' from '/api/auth/login/' and token extraction accordingly.\n    \"\"\"\n    login_url = f\"{BASE_URL}/api/token/\"\n    payload = {\n        \"username\": ADMIN_USERNAME,\n        \"password\": ADMIN_PASSWORD\n    }\n    try:\n        resp = requests.post(login_url, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Failed to authenticate admin user: {e}\"\n    data = resp.json()\n    token = data.get(\"access\")\n    if not token:\n        assert False, \"Authentication did not return an access token\"\n    return token\n\ndef create_announcement(token, title, message):\n    url = f\"{BASE_URL}/api/admin/announcements/\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\",\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"title\": title,\n        \"message\": message,\n        \"broadcast\": True  # Assuming a broadcast flag to trigger notifications\n    }\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Announcement creation request failed: {e}\"\n    return response.json()\n\ndef delete_announcement(token, announcement_id):\n    url = f\"{BASE_URL}/api/admin/announcements/{announcement_id}/\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    try:\n        resp = requests.delete(url, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        # Log but do not fail test on cleanup failure\n        print(f\"Warning: Failed to delete announcement {announcement_id}: {e}\")\n\ndef get_notifications(token, announcement_title):\n    url = f\"{BASE_URL}/api/notifications/\"\n    headers = {\n        \"Authorization\": f\"Bearer {token}\"\n    }\n    try:\n        resp = requests.get(url, headers=headers, timeout=TIMEOUT)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Fetching notifications failed: {e}\"\n    notifications = resp.json()\n    # Filter notifications related to the announcement title\n    filtered = [n for n in notifications if announcement_title in n.get(\"message\", \"\") or announcement_title in n.get(\"title\", \"\")]\n    return filtered\n\ndef test_admin_announcement_broadcast():\n    token = get_admin_token()\n    announcement_title = \"Important Clinic Update\"\n    announcement_message = \"All patients must wear masks starting next week.\"\n    announcement = None\n\n    try:\n        # Create announcement\n        announcement = create_announcement(token, announcement_title, announcement_message)\n        announcement_id = announcement.get(\"id\")\n        assert announcement_id is not None, \"Announcement ID missing in response\"\n        assert announcement.get(\"title\") == announcement_title\n        assert announcement.get(\"message\") == announcement_message\n        assert announcement.get(\"broadcast\") is True or announcement.get(\"status\") == \"broadcasted\"\n\n        # Validate that notification for announcement is delivered properly\n        # This may require some delay or retry mechanism if notifications are processed asynchronously\n        import time\n        retries = 5\n        found_notifications = []\n        for _ in range(retries):\n            found_notifications = get_notifications(token, announcement_title)\n            if found_notifications:\n                break\n            time.sleep(2)\n        assert found_notifications, \"No notification related to announcement found\"\n\n        # Check notification content correctness\n        for notif in found_notifications:\n            assert \"title\" in notif or \"message\" in notif\n            # Notification should mention the announcement message or title\n            assert announcement_title in notif.get(\"title\", \"\") or announcement_message in notif.get(\"message\", \"\")\n\n    finally:\n        if announcement and announcement.get(\"id\"):\n            delete_announcement(token, announcement[\"id\"])\n\ntest_admin_announcement_broadcast()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 22, in get_admin_token\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:9000/api/token/\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 113, in <module>\n  File \"<string>\", line 77, in test_admin_announcement_broadcast\n  File \"<string>\", line 24, in get_admin_token\nAssertionError: Failed to authenticate admin user: 404 Client Error: Not Found for url: http://localhost:9000/api/token/\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-01-12T15:07:02.223Z",
    "modified": "2026-01-12T15:08:47.961Z"
  }
]
